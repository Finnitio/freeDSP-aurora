
#include <Wire.h>
#include <WiFi.h>
#include <ArduinoJson.h>
//#include "BluetoothSerial.h"
#include "SPIFFS.h"


#define I2C_SDA_PIN 16
#define I2C_SCL_PIN 4

#define FORMAT_SPIFFS_IF_FAILED true

#define DSP_ADDR (0x70>>1)

enum
{
  RESET      = 0x01,
  NEWFW      = 0x02,
  VERIFY     = 0x03,
  PARAM      = 0x04,
  SAVEPARAMS = 0x05
};

enum
{
  STATUS_IDLE,
  STATUS_WAITDATASIZE,
  STATUS_RECVFW,
  STATUS_VERIFY,
  STATUS_PARAM_NUMBYTES,
  STATUS_PARAM_REG,
  STATUS_PARAM_VALUE,
  STATUS_WAIT_NUMBYTES,
  STATUS_STORE_PARAMS,
  STATUS_RETURN_PARAMS
};

enum twifistatus
{
  STATE_WIFI_IDLE,
  STATE_WIFI_PUTPARAM,


  STATE_WIFI_RECEIVE_USERPARAM,
  STATE_WIFI_RECEIVE_SINGLEPARAM
};

struct tSettings
{
  byte pid;
};

tSettings Settings;

//BluetoothSerial SerialBT;

int state;
int numBytes = 0;
int cntr = 0;
uint16_t dspRegister = 0;
uint32_t dspValueHex = 0;
float dspValue;

File fileDspProgram;
File fileDspParams;

File fileUserParams;

WiFiClient client;
WiFiServer server( 8088 );

twifistatus wifiStatus = STATE_WIFI_IDLE;
int cntrPackets = 0;

//==============================================================================
/*! 
 */
String byte2string( byte val )
{
  String str( "0x" );
  if( val < 0x10 )
    str += "0";
  str += String( val, HEX );  
  return str;
}

String byte2string2( byte val )
{
  String str;
  if( val < 0x10 )
    str += "0";
  str += String( val, HEX );  
  return str;
}

//==============================================================================
/*! 
 */
void scan()
{
Serial.println(" Scanning I2C Addresses");
uint8_t cnt=0;
for(uint8_t i=0;i<128;i++){
  Wire.beginTransmission(i);
  uint8_t ec=Wire.endTransmission(true);
  if(ec==0){
    if(i<16)Serial.print('0');
    Serial.print(i,HEX);
    cnt++;
  }
  else Serial.print("..");
  Serial.print(' ');
  if ((i&0x0f)==0x0f)Serial.println();
  }
Serial.print("Scan Completed, ");
Serial.print(cnt);
Serial.println(" I2C Devices found.");
}

#if 0
//==============================================================================
/*! Uploads the firmware from ESP32 SPI flash to DSP.
 */
void uploadDspFirmware( void )
{
  Serial.print( "Init dsp......" );

  fileDspProgram = SPIFFS.open( "/dspinit.hex" );

  uint32_t numBytesToRead = 0;

  if( fileDspProgram )
  {
    int file_size = fileDspProgram.size();

    cntr = 0;

    while( fileDspProgram.available() )
    {
      uint32_t byteRead = fileDspProgram.read();
      numBytesToRead = (numBytesToRead << 8) + byteRead;
      byteRead = fileDspProgram.read();
      numBytesToRead = (numBytesToRead << 8) + byteRead;
      byteRead = fileDspProgram.read();
      numBytesToRead = (numBytesToRead << 8) + byteRead;
      byteRead = fileDspProgram.read();
      numBytesToRead = (numBytesToRead << 8) + byteRead;

      cntr += 4;

      //Serial.print( "numBytesToRead " );
      //Serial.println( numBytesToRead, HEX );

      //------------------------------------------------------------------------
      //--- Send register address
      //------------------------------------------------------------------------
      Wire.beginTransmission( DSP_ADDR );

      //Serial.println( "Register" );
      byteRead = fileDspProgram.read();
      Wire.write( byteRead );
      //Serial.println( byteRead, HEX );
      byteRead = fileDspProgram.read();
      Wire.write( byteRead );
      //Serial.println( byteRead, HEX );

      cntr += 2;

      //Serial.println( "Value" );
      for( uint32_t n = 0; n < numBytesToRead - 2; n++ )
      {
        byteRead = fileDspProgram.read();
        Wire.write( byteRead );
        cntr++;
        //Serial.println( byteRead, HEX );
      }

      Wire.endTransmission( true );

    }

    fileDspProgram.close();

  }
  else
    Serial.println( "\n[ERROR] Failed to open file dspinit.hex" );
  Serial.print( "[ok]\n" );
  //Serial.print( "Read ");
  //Serial.print( cntr );
  //Serial.println( " bytes");
}

//==============================================================================
/*! Uploads the parameters from ESP32 SPI flash to DSP.
 */
void uploadDspParameter( void )
{
  Serial.print( "Loading dsp parameter......" );

  fileDspParams = SPIFFS.open( "/dspparam.hex" );

  //uint32_t numBytesToRead = 0;

  if( fileDspParams )
  {
    int file_size = fileDspParams.size();

    cntr = 0;

    while( fileDspParams.available() )
    {
      //------------------------------------------------------------------------
      //--- Send register address
      //------------------------------------------------------------------------
      Wire.beginTransmission( DSP_ADDR );

      Serial.println( "Register" );
      uint32_t byteRead = fileDspParams.read();
      Wire.write( byteRead );
      Serial.println( byteRead, HEX );
      byteRead = fileDspParams.read();
      Wire.write( byteRead );
      Serial.println( byteRead, HEX );
      cntr += 2;

      //------------------------------------------------------------------------
      //--- Send value
      //------------------------------------------------------------------------
      Serial.println( "Value" );
      for( uint32_t n = 0; n < 4; n++ )
      {
        byteRead = fileDspParams.read();
        Wire.write( byteRead );
        cntr++;
        Serial.println( byteRead, HEX );
      }

      Wire.endTransmission( true );

    }

    Serial.print( cntr );
    Serial.println( "Bytes" );

    fileDspParams.close();

  }
  else
    Serial.println( "\n[ERROR] Failed to open file dspinit.hex" );
  Serial.print( "[ok]\n" );
}

//==============================================================================
/*! Returns the parameter to host.
 */
void returnDspParameters( void )
{
  Serial.print( "Returning dsp parameter......" );

  fileDspParams = SPIFFS.open( "/dspparam.hex" );

  if( fileDspParams )
  {
    int file_size = fileDspParams.size();

    cntr = 0;

    //--------------------------------------------------------------------------
    //--- Send file size
    //--------------------------------------------------------------------------
    SerialBT.write( (file_size>>24) & 0xFF );
    SerialBT.write( (file_size>>16) & 0xFF );
    SerialBT.write( (file_size>>8) & 0xFF );
    SerialBT.write( file_size & 0xFF );

    Serial.print( "File size:" );
    Serial.println( file_size, HEX );

    while( fileDspParams.available() )
    {
      //------------------------------------------------------------------------
      //--- Send register address
      //------------------------------------------------------------------------
      Serial.println( "Register" );
      uint32_t byteRead = fileDspParams.read();
      SerialBT.write( byteRead );
      Serial.println( byteRead, HEX );
      byteRead = fileDspParams.read();
      SerialBT.write( byteRead );
      Serial.println( byteRead, HEX );
      cntr += 2;


      //------------------------------------------------------------------------
      //--- Send value
      //------------------------------------------------------------------------
      Serial.println( "Value" );
      for( uint32_t n = 0; n < 4; n++ )
      {
        byteRead = fileDspParams.read();
        SerialBT.write( byteRead );
        cntr++;
        Serial.println( byteRead, HEX );
      }
    }

    Serial.print( cntr );
    Serial.println( "Bytes" );

    fileDspParams.close();
  }
  else
    Serial.println( "\n[ERROR] Failed to open file dspinit.hex" );
  Serial.print( "[ok]\n" );
}
#endif

//==============================================================================
/*! Arduino Setup
 */
void setup()
{
  Wire.begin( I2C_SDA_PIN, I2C_SCL_PIN );
  Wire.setClock( 100000 );

  Serial.begin(115200);
  Serial.println( "aurora Debug" );

  if( !SPIFFS.begin( FORMAT_SPIFFS_IF_FAILED ) )
  {
    Serial.println( "An Error has occurred while mounting SPIFFS" );
    return;
  }

  //----------------------------------------------------------------------------
  //--- Configure ESP for WiFi access
  //----------------------------------------------------------------------------
  WiFi.mode( WIFI_AP_STA );
  // Start access point
  WiFi.softAP( "freeDSP-aurora" );
  delay(100);
  //wait for SYSTEM_EVENT_AP_START
  if( !WiFi.softAPConfig( IPAddress(192, 168, 5, 1), IPAddress(192, 168, 5, 1), IPAddress(255, 255, 255, 0) ) )
      Serial.println("AP Config Failed");
  // print the ESP32 IP-Address
  Serial.println( WiFi.softAPIP() );
  server.begin();

  //----------------------------------------------------------------------------
  //--- Load system settings
  //----------------------------------------------------------------------------
  if( SPIFFS.exists( "/settings.ini" ) )
  {
    File fileSettings = SPIFFS.open( "/settings.ini" );
    Serial.println( "Reading settings.ini" );
    // Allocate a temporary JsonDocument
    // Don't forget to change the capacity to match your requirements.
    // Use arduinojson.org/assistant to compute the capacity.
    StaticJsonDocument<256> jsonSettings;
    // Deserialize the JSON document
    DeserializationError error = deserializeJson( jsonSettings, fileSettings );
    if( error )
      Serial.println( "Failed to read settings.ini" );
    Settings.pid = jsonSettings["pid"];
    Serial.print( "pid: " );
    Serial.println( Settings.pid, HEX );
    fileSettings.close();
  }
  else
  {
    Serial.println( "Settings.ini not found, rewriting" );
    File fileSettings = SPIFFS.open( "/settings.ini", "w" );
    // Allocate a temporary JsonDocument
    // Don't forget to change the capacity to match your requirements.
    // Use arduinojson.org/assistant to compute the capacity.
    StaticJsonDocument<256> jsonSettings;
    jsonSettings["pid"] = 0x01;
    // Serialize JSON to file
    if( serializeJson( jsonSettings, fileSettings ) == 0 )
      Serial.println( "Failed to write to file" );
    fileSettings.close();
  }
  


  //----------------------------------------------------------------------------
  //--- Download program to DSP
  //----------------------------------------------------------------------------
  //uploadDspFirmware();

  //----------------------------------------------------------------------------
  //--- Download user parameter to DSP
  //----------------------------------------------------------------------------
  //uploadDspParameter();



  state = STATUS_IDLE;
  wifiStatus = STATE_WIFI_IDLE;

  //SerialBT.begin( "freedsp-aurora" );

}

String WebRequestHostAddress;     // global variable used to store Server IP-Address of HTTP-Request

//  Call this function regularly to look for client requests
//  template see https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFi/examples/SimpleWiFiServer/SimpleWiFiServer.ino
//  returns empty string if no request from any client
//  returns GET Parameter: everything after the "/?" if ADDRESS/?xxxx was entered by the user in the webbrowser
//  returns "-" if ADDRESS but no GET Parameter was entered by the user in the webbrowser
//  remark: client connection stays open after return



String Webserver_GetRequestGETParameter()
{
  String GETParameter = "";
  int wifiExpectedBytes = 0;
  int wifiRxBytes = 0;
  int cntrLine = 0;
  bool waitForData = false;
  
  
  client = server.available();               // listen for incoming clients
  
  if( client )                              // if you get a client,
  {
    Serial.println("Webserver_GetRequestGETParameter(): New Client.");           // print a message out the serial port
    String currentLine = "";                 // make a String to hold incoming data from the client
    
    while( client.connected() )            // loop while the client's connected
    {  
      if( client.available() )            // if there's bytes to read from the client,
      {  
        char c = client.read();                                                 // read a new byte
        Serial.print( c );
        if( c != '\r' )
          currentLine += c;                                                     // add it to the end of the currentLine
        if( c == '\n' )                                                         // if the byte is a newline character
        {
//          cntrLine++;
          //Serial.println( currentLine );
         
          if( waitForData )
          {
            //Serial.println( currentLine );

            if( wifiStatus == STATE_WIFI_PUTPARAM )
            {
              Serial.println( currentLine );
              if( currentLine.length() < 12 )
                Serial.println( "Not enough data" );
              else
              {
              //int sentBytes = 0;
              //while( sentBytes + 12 < currentLine.length() )
              //{
                String strReg = currentLine.substring( 0, 4 );
                String strData = currentLine.substring( 4, 13 );
                //Serial.println( strReg );
                //Serial.println( strData );
                uint16_t reg = (uint16_t)strtoul( strReg.c_str(), NULL, 16 );
                uint32_t data = (uint32_t)strtoul( strData.c_str(), NULL, 16 );
                
                Wire.beginTransmission( DSP_ADDR );
                Serial.print( "I2C " );
                byte byteTx = (reg>>8) & 0xff;
                Serial.print( byte2string2(byteTx) );
                Wire.write( byteTx );
                byteTx = reg & 0xff;
                Serial.print( byte2string2(byteTx) );
                Wire.write( byteTx );
                Serial.print( " " ); 
                
                byteTx = (data>>24) & 0xff;
                Serial.print( byte2string2(byteTx) );
                Wire.write( byteTx );
                byteTx = (data>>16) & 0xff;
                Serial.print( byte2string2(byteTx) );
                Wire.write( byteTx );
                byteTx = (data>>8) & 0xff;
                Serial.print( byte2string2(byteTx) );
                Wire.write( byteTx );
                byteTx = data & 0xff;
                Serial.println( byte2string2(byteTx) );
                Wire.write( byteTx );               
                Wire.endTransmission( true );
                //sentBytes += 12;
              } 
              //}
              client.stop();
            }

            currentLine = "";
            //Serial.println( cntrPackets );
            waitForData = false;
          }
          else
          {
            //Serial.println( currentLine );
            //--- New single dsp parameter sent
            if( currentLine.startsWith("PUT /param") )
            {
              Serial.println( "PUT /param" );
              wifiStatus = STATE_WIFI_PUTPARAM;
              currentLine = "";
              cntrPackets++;
            }

            else if( currentLine.startsWith("Host:") )
            {
              //Serial.println( currentLine );
              currentLine = "";
            }

            else if( currentLine.startsWith("Content-type:") )
            {
              //Serial.println( currentLine );
              currentLine = "";
            }

            //--- Content-length
            else if( currentLine.startsWith( "Content-length" ) )
            {
              //Serial.println( currentLine );
              //String str = currentLine.substring( currentLine.indexOf(':') + 1, currentLine.length() );
              currentLine = "";
            }

            //--- Begin of Content line
            else if( currentLine.startsWith( "\n" ) )
            {
              waitForData = true;
              currentLine = "";
            }
          }
          

          #if 0
          Serial.print( "CL " );
          Serial.print( wifiRxBytes );
          Serial.print( wifiExpectedBytes ); 
          Serial.println( currentLine );
          

          

          //--- Empty line
          else if( currentLine.startsWith( "\n" ) )
          {
            Serial.println( "NL" );
            wifiRxBytes = 0;
            currentLine = "";
          }

          //--- Receiving content
          /*else if( wifiRxBytes < wifiExpectedBytes )
          {
            wifiRxBytes++;
            Serial.println( c );
            if( wifiRxBytes == wifiExpectedBytes )
            {
              Serial.println( currentLine );
              currentLine = "";
              wifiStatus = STATE_WIFI_IDLE;
            }
          }*/

          else
            currentLine = "";
            #endif

        }

        #if 0
        if( (wifiStatus == STATE_WIFI_RECEIVE_USERPARAM) && (wifiRxBytes < wifiExpectedBytes) )
        {
          wifiRxBytes++;

          byte rxByte = c;
          fileUserParams.write( rxByte );
          Serial.print( wifiRxBytes );
          Serial.print( " " );
          Serial.println( byte2string(rxByte) );
          if( wifiRxBytes == wifiExpectedBytes )
          {
            Serial.println( "Closing usrparam.hex" );
            fileUserParams.flush();
            fileUserParams.close();
            wifiStatus = STATE_WIFI_IDLE;
            wifiRxBytes = wifiExpectedBytes = 0;
          } 
        }
        if( (wifiStatus == STATE_WIFI_RECEIVE_SINGLEPARAM) && (wifiRxBytes < wifiExpectedBytes) )
        {
          wifiRxBytes++;

          byte rxByte = c;
          fileUserParams.write( rxByte );
          Serial.print( wifiRxBytes );
          Serial.print( " " );
          Serial.println( byte2string(rxByte) );
          if( wifiRxBytes == wifiExpectedBytes )
          {
            Serial.println( "Received param" );
            wifiStatus = STATE_WIFI_IDLE;
            wifiRxBytes = wifiExpectedBytes = 0;
          } 
        }
        else
        {
          
          currentLine += c;      // add it to the end of the currentLine
          if (c == '\n')                     // if the byte is a newline character
          {
            // if the current line is blank, you got two newline characters in a row.
            // that's the end of the client HTTP request
            /*if (currentLine.length() == 0) 
            {  
              if (GETParameter == "") {GETParameter = "-";};    // if no "GET /?" was found so far in the request bytes, return "-"
              
              // break out of the while loop:
              break;
          
            } 
            else {    // if you got a newline, then clear currentLine:
              currentLine = "";
            }*/
            
          } 
          else if (c != '\r')  // if you got anything else but a carriage return character,
            currentLine += c;      // add it to the end of the currentLine
        
        //if (c=='\r' && currentLine.startsWith("GET /?")) 
        // we see a "GET /?" in the HTTP data of the client request
        // user entered ADDRESS/?xxxx in webbrowser, xxxx = GET Parameter
        //{
         // 
        //  GETParameter = currentLine.substring(currentLine.indexOf('?') + 1, currentLine.indexOf(' ', 6));    // extract everything behind the ? and before a space          
        //}


        

        //--- Request of DSP-plugin id
        if( c=='\r' && currentLine.startsWith("GET /pid") )
        {
          Serial.println( "GET pid" );
          String httpResponse = "";
          httpResponse += "HTTP/1.1 200 OK\r\n";
          httpResponse += "Content-type:application/octet-stream\r\n\r\n";
          httpResponse += byte2string( Settings.pid );
          httpResponse += "\r\n";
          client.println(httpResponse);
          // \TODO Do we need this here?
          client.stop();
        }

        //--- Request of user params
        if( c=='\r' && currentLine.startsWith("GET /userparams") )
        {
          Serial.println( "GET userparams" );
          if( SPIFFS.exists( "/usrparam.hex" ) )
          {
            fileUserParams = SPIFFS.open( "/usrparam.hex" );
            String httpResponse = "HTTP/1.1 200 OK\r\n";
            httpResponse += "Content-type:application/octet-stream\r\n";
            httpResponse += "Content-length:" + String( fileUserParams.size()*2 );
            httpResponse += "\r\n\r\n";
            while( fileUserParams.available() )
            {
              byte byteRead = fileUserParams.read();
              httpResponse += byte2string2(byteRead);
              Serial.println( byte2string(byteRead) );
            }
            Serial.println( httpResponse );
            client.println(httpResponse);

            fileUserParams.close();
          }
          else
          {
            Serial.println( "/usrparam.hex does not exist." );
            String httpResponse = "HTTP/1.1 200 OK\r\n";
            httpResponse += "Content-type:application/octet-stream\r\n";
            httpResponse += "Content-length:0";
            httpResponse += "\r\n\r\n";
            client.println(httpResponse);
          }
          

          //String httpResponse = "";
          //httpResponse += "HTTP/1.1 200 OK\r\n";
          //httpResponse += "Content-type:application/octet-stream\r\n\r\n";
          //httpResponse += byte2string( Settings.pid );
          //httpResponse += "\r\n";
          //client.println(httpResponse);
          // \TODO Do we need this here?
          client.stop();
        }

        //--- New user parameters sent
        else if( c=='\r' && currentLine.startsWith("PUT /userparams") )
        {
          Serial.println( "PUT /userparams" );
          if( SPIFFS.exists( "/usrparam.hex" ) )
          {
            if( SPIFFS.remove( "/usrparam.hex" ) )
              Serial.println( "usrparam.hex deleted" );
          }

          fileUserParams = SPIFFS.open( "/usrparam.hex", FILE_APPEND );
          if( !fileUserParams )
            Serial.println( "[ERROR] Failed to open file usrparam.hex" );

          wifiExpectedBytes = 0;
          wifiStatus = STATE_WIFI_RECEIVE_USERPARAM;
        }

        //--- New single dsp parameter sent
        else if( c=='\r' && currentLine.startsWith("PUT /param") )
        {
          Serial.println( "PUT /param" );
          wifiExpectedBytes = 0;
          wifiStatus = STATE_WIFI_RECEIVE_SINGLEPARAM;
        }

        else if (c=='\r' && currentLine.startsWith("Host:")) 
        // we see a "Host:" in the HTTP data of the client request
        // user entered ADDRESS or ADDRESS/... in webbrowser, ADDRESS = Server IP-Address of HTTP-Request
        {
          int IndexOfBlank = currentLine.indexOf(' ');
          WebRequestHostAddress = currentLine.substring(IndexOfBlank + 1, currentLine.length());    // extract everything behind the space character and store Server IP-Address of HTTP-Request
          
        }

        else if( c=='\r' && currentLine.startsWith( "Content-length" ) )
        {
          Serial.println( currentLine );
          String str = currentLine.substring( currentLine.indexOf(':') + 1, currentLine.length() );
          wifiExpectedBytes = str.toInt();
          wifiRxBytes = wifiExpectedBytes;
        }

        else if( c=='\n' && wifiExpectedBytes > 0 && wifiStatus != STATE_WIFI_IDLE )
        {
          Serial.println( "Start rx Content" );
          wifiRxBytes = 0;
        }

        }

        /*
        else if( c=='\r' && wifiExpectedBytes > 0 )
        {
          Serial.println( "Received content" );
          Serial.println( currentLine );
          Serial.println( currentLine.length() );
          wifiExpectedBytes = 0;
        }*/


        #endif
      }
      
    }
    
  }

  return GETParameter;
}


// Decodes a GET parameter (expression after ? in URI (URI = expression entered in address field of webbrowser)), like "Country=Germany&City=Aachen"
// and set the ConfigValues
int DecodeGETParameterAndSetConfigValues(String GETParameter)
{
   
   int posFirstCharToSearch = 1;
   int count = 0;
   
   // while a "&" is in the expression, after a start position to search
   while (GETParameter.indexOf('&', posFirstCharToSearch) > -1)
   {
     int posOfSeparatorChar = GETParameter.indexOf('&', posFirstCharToSearch);  // position of & after start position
     int posOfValueChar = GETParameter.indexOf('=', posFirstCharToSearch);      // position of = after start position
  
  //   ConfigValue[count] = GETParameter.substring(posOfValueChar + 1, posOfSeparatorChar);  // extract everything between = and & and enter it in the ConfigValue
      
     posFirstCharToSearch = posOfSeparatorChar + 1;  // shift the start position to search after the &-char 
     count++;
   }

   // no more & chars found
   
   int posOfValueChar = GETParameter.indexOf('=', posFirstCharToSearch);       // search for =
   
//   ConfigValue[count] = GETParameter.substring(posOfValueChar + 1, GETParameter.length());  // extract everything between = and end of string
   count++;

   return count;  // number of values found in GET parameter
}

// check the ConfigValues and set ConfigStatus
// process the first ConfigValue to switch something
void ProcessAndValidateConfigValues(int countValues)
{
  if (countValues > 8) {countValues = 8;};

  // if we have more than 1 value, store the second and third value in non-volatile storage
  if (countValues > 2)
  {
    //preferences.putString("SSID", ConfigValue[1]);
    //preferences.putString("Password", ConfigValue[2]);
  }

  /*
  // in our application the first value must be "00" or "FF" (as text string)
  if ((ConfigValue[0].equals("00")) || (ConfigValue[0].equals("FF")))
  {
    ConfigStatus[0] = 1;    // Value is valid
  }
  else
  {
    ConfigStatus[0] = -1;   // Value is not valid
  }

  // first config value is used to switch LED ( = Actor)
  if (ConfigValue[0].equals("00"))   
  {
    SwitchActor(ACTOR_OFF);
  }
  
  if (ConfigValue[0].equals("FF"))
  {
    SwitchActor(ACTOR_ON);
  }*/
  
}


// Get IP-Address of ESP32 in Router network (LAN), in String-format
String WiFi_GetOwnIPAddressInRouterNetwork()
{
  return WiFi.localIP().toString();
}


void loop()
{
  //client = server.available();               // listen for incoming clients
  
   String GETParameter = Webserver_GetRequestGETParameter();   // look for client request
 
  /*if( GETParameter.length() > 0 )        // we got a request, client connection stays open
    {
      if (GETParameter.length() > 1)      // request contains some GET parameter
      {
          int countValues = DecodeGETParameterAndSetConfigValues(GETParameter);     // decode the GET parameter and set ConfigValues
  
  
          ProcessAndValidateConfigValues(1);                 // then only the LED must be switched
       
      }

      String HTMLPageWithConfigForm;
       
      if (WebRequestHostAddress == "192.168.4.1")                  //   the user entered this address in the browser, to get the configuration webpage               
      {
          HTMLPageWithConfigForm = EncodeFormHTMLFromConfigValues("ESP32 Webserver CONFIG", 3) + "<br>IP Address: " + WiFi_GetOwnIPAddressInRouterNetwork();       // build a new Configuration webpage with form and new ConfigValues entered in textboxes
      }
      else                                                         // the user entered the ESP32 address in router network in the browser, to get normal webpage
      {
          HTMLPageWithConfigForm = EncodeFormHTMLFromConfigValues("ESP32 Webserver Demo", 1);                                       // build a new webpage to control the LED
      }
      
      //Webserver_SendHTMLPage(HTMLPageWithConfigForm);    // send out the webpage to client = webbrowser and close client connection
      
  }*/


  delay( 50 );

#if 0
  int rxByte;


  if( state == STATUS_IDLE )
  {
    if( SerialBT.available() )
    {
      rxByte = SerialBT.read();
      if( rxByte == NEWFW )
      {
        Serial.println( "Receiving new image" );
        numBytes = 0;
        cntr = 0;
        state = STATUS_WAITDATASIZE;
      }
      else if( rxByte == VERIFY )
      {
        Serial.println( "Verifying DSP firmware" );
        state = STATUS_VERIFY;
      }
      else if( rxByte == PARAM )
      {
        Serial.println( "Receiving Parameter" );
        numBytes = 0;
        cntr = 0;
        state = STATUS_PARAM_REG;
      }
      else if( rxByte == SAVEPARAMS )
      {
        Serial.println( "Storing Parameters" );
        numBytes = 0;
        cntr = 0;
        state = STATUS_WAIT_NUMBYTES;
      }
      else if( rxByte == GETPARAMS )
      {
        Serial.println( "Returning Parameters" );
        numBytes = 0;
        cntr = 0;
        status = STATUS_RETURN_PARAMS;
      }
      else
        Serial.println( "Unkown command" );
      SerialBT.write( rxByte );
    }
  }

  else if( state == STATUS_WAITDATASIZE )
  {
    if( SerialBT.available() )
    {
      rxByte = SerialBT.read();
      numBytes = (numBytes << 8) + rxByte;
      cntr++;

      if( cntr == 4 )
      {
        Serial.print( numBytes );
        Serial.println( "bytes" );

        if( SPIFFS.exists( "/dspinit.hex" ) )
        {
          if( SPIFFS.remove( "/dspinit.hex" ) )
            Serial.println( "dspinit.hex deleted" );
        }

        fileDspProgram = SPIFFS.open( "/dspinit.hex", FILE_APPEND );
        if( !fileDspProgram )
          Serial.println( "[ERROR] Failed to open file dspinit.hex" );
        cntr = 0;
        state = STATUS_RECVFW;
      }

      SerialBT.write( rxByte );
    }

  }

  else if( state == STATUS_RECVFW )
  {
    if( SerialBT.available() )
    {
      rxByte = SerialBT.read();

      size_t len = fileDspProgram.write( rxByte );
      if( len != 1 )
        Serial.println( "Error writing to file dspinit.hex" );
      else
      {
        Serial.print( cntr+1 );
        Serial.print( " : " );
        Serial.print( rxByte, HEX );
        Serial.print( "\n" );
      }

      cntr++;
      if( cntr == numBytes )
      {
        fileDspProgram.flush();
        fileDspProgram.close();
        Serial.println( "Closed dspinit.hex" );

        cntr = 0;
        state = STATUS_IDLE;
      }
      SerialBT.write( rxByte );
    }
  }

  else if( state == STATUS_VERIFY )
  {
    fileDspProgram = SPIFFS.open( "/dspinit.hex" );

    if( fileDspProgram )
    {
      int file_size = fileDspProgram.size();
      Serial.print( "File size: " );
      Serial.println( file_size );

      for( int ii = 0; ii < file_size; ii++ )
      {
        uint8_t nextByte = fileDspProgram.read();

        Serial.println( nextByte, HEX );
      }

      fileDspProgram.close();

    }
    else
      Serial.println( "[ERROR] Failed to open file dspinit.hex" );

    state = STATUS_IDLE;
  }

  else if( state == STATUS_PARAM_NUMBYTES )
  {
    if( SerialBT.available() )
    {
      rxByte = SerialBT.read();
      numBytes = (numBytes << 8) + rxByte;
      cntr++;

      if( cntr == 4 )
      {
        Serial.print( numBytes );
        Serial.println( "bytes" );
        cntr = 0;
        state = STATUS_PARAM_REG;
      }

      SerialBT.write( rxByte );
    }
  }

  else if( state == STATUS_PARAM_REG )
  {
    if( SerialBT.available() )
    {
      rxByte = SerialBT.read();
      dspRegister = (dspRegister << 8) + rxByte;
      cntr++;

      if( cntr == 2 )
      {
        Serial.println( dspRegister );
        cntr = 0;
        dspValueHex = 0;
        state = STATUS_PARAM_VALUE;
      }

      SerialBT.write( rxByte );
    }
  }

  //----------------------------------------------------------------------------
  //--- Get the register value
  //----------------------------------------------------------------------------
  else if( state == STATUS_PARAM_VALUE )
  {
    if( SerialBT.available() )
    {
      rxByte = SerialBT.read();
      dspValueHex = (dspValueHex << 8) + rxByte;
      cntr++;

      if( cntr == 4 )
      {
        memcpy( &dspValue, &dspValueHex, sizeof(float) );
        Serial.println( dspValue );
        cntr = 0;
        dspValueHex = 0;
        state = STATUS_IDLE;
      }

      SerialBT.write( rxByte );
    }
  }

  //----------------------------------------------------------------------------
  //--- Get the length of dspparams.hex in bytes
  //----------------------------------------------------------------------------
  else if( state == STATUS_WAIT_NUMBYTES )
  {
    if( SerialBT.available() )
    {
      rxByte = SerialBT.read();
      numBytes = (numBytes << 8) + rxByte;
      cntr++;

      if( cntr == 4 )
      {
        Serial.print( numBytes );
        Serial.println( "bytes" );

        if( SPIFFS.exists( "/dspparam.hex" ) )
        {
          if( SPIFFS.remove( "/dspparam.hex" ) )
            Serial.println( "dspparams.hex deleted" );
        }

        fileDspParams = SPIFFS.open( "/dspparam.hex", FILE_APPEND );
        if( !fileDspParams )
          Serial.println( "[ERROR] Failed to open file dspparam.hex" );

        cntr = 0;
        state = STATUS_STORE_PARAMS;
      }

      SerialBT.write( rxByte );
    }
  }

  //----------------------------------------------------------------------------
  //--- Get the file dspparams.hex byte by byte
  //----------------------------------------------------------------------------
  else if( state == STATUS_STORE_PARAMS )
  {
    if( SerialBT.available() )
    {
      rxByte = SerialBT.read();

      fileDspParams.write( rxByte );
      Serial.println( rxByte, HEX );

      cntr++;
      if( cntr == numBytes )
      {
        fileDspParams.flush();
        fileDspParams.close();
        Serial.println( "Closed dspparam.hex" );
        cntr = 0;
        state = STATUS_IDLE;
      }

      SerialBT.write( rxByte );
    }
  }

  #endif

   //Wire.beginTransmission( DSP_ADDR );
   //Wire.endTransmission();

}
